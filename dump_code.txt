#     def update_unspent_btc_from_blockchain(self,miner):
#         for block in blockchain.blockchain:
#             self.update_unspent_btc_from_block(block)
            
#     def update_unspent_btc_from_block(self,block):
#         for tx in block.transactions:
#             txid = tx.txid
#             sender_address = bytes.fromhex(tx.sender_address)
#             for index,output in enumerate(tx.tx_out):
#                 if output.to_address == self.public_key_hash:
#                     key = txid+"-"+str(index)
#                     if key not in self.secured_unspent_btc:
#                         print("{} Received {} BTC from {}".format(str(self.id),str(output.amount),self.node_id_of_public_key[sender_address]))
#                         self.secured_unspent_btc[key] = [sender_address,output.amount,txid,index]
#                         self.btc += output.amount
#                     else:
#                         print("already received money from this transaction,",  self.id)
                        
#             if sender_address == self.public_key:
#                 for index,input in enumerate(tx.tx_in):
#                     key = input.prev_output_tid +"-"+str(input.prev_output_index)
#                     self.btc -= self.secured_unspent_btc[key]
#                     print("{} have spent {} BTC".format(str(self.id),str(self.btc)))
#                     del self.secured_unspent_btc[key]



        
        ### Block for mining #####
        # Now mining work starts
        
                
            
            
            
            
            
            
            
            
            
            
            
            #print(self.blockchain)
        #print(self.secured_unspent_btc,self.btc,self.id)
        # if self.id ==0:
        #    print(self.blockchain)  
        #print("Done and return," , self.id)
        
        ### Block for doing transaction ####
            
            
        
        ### Now each node will select a random node and will send it money 
        ### Once it does send/receive then it wont send any money to any other node for 10 seconds
        ### Further each node will engange in mining the blocks, as soon it finishes, it will send the blocks to everyone and everyone will validate the block before adding it.
        ### Once they validate, 
#         while not done:
#             try:
#                 msg = msg_qs[self.id].get(block=True,timeout=10)
#                 if msg.type == "PUBLIC_KEY":
#                     self.update_public_key_of_node(msg.src,msg.msg)
#                 if msg.type == "TRANSACTION":
#                     #### collect the transaction ###
#                 if msg.type == "BLOCK":
#                     ### add the block and verify it
                    
                
#                 #print("Received message")
#                 print("Received message  ," +str(msg))
#                 ct += 1
#             except Q.Empty:
#                 print("No new message in 5 seconds , got messages from {} exitin {}".format(str(ct),str(self.id)))
#                 #outputq.put("I am done {}".format(str(self.id)))
#                 done = True
#                 #return
        
    
    def create_block(self,blockchain):
        in_btc = 0
        out_btc = 0
        block_creation_award = 2
        for transact in self.transactions_collected:
            for ins in transact.tx_in:
                amount = blockchain.get_amount_for_txid_and_index(ins.prev_output_tid,ins.index)
                if amount is None:
                    return None ### means referenced input transactions dont exist in blockchain
                in_btc += amount
            for outs in transact.tx_out:
                out_btc += outs.amount
        total_reward = block_creation_award + out_btc - in_btc
        inputs = [Input('None','None')]
        outputs = [Output(self.public_keys_of_nodes[self.id].hex(),total_reward,self.hash_type)]
        transaction = Transaction(self.public_keys_of_nodes[self.id],inputs,outputs,self.private_key,t_type = 'COINBASE',hash_type=self.hash_type)
        self.transactions_collected = [transaction] + self.transactions_collected
        block = Block(self.proof_of_work_zeros,len(blockchain.blockchain),self.narry,self.transactions_collected ,blockchain.blockchain[-1].block_hash,self.hash_type,block_type="Regular")
        return block
        ### now create a new transactions and put this money to self account
        
    def verify_block(block):
        return self.is_proof_of_work_correct(block) and self.verify_transactions(block)
    def verify_genesis_block(self,blockchain):
        return self.is_proof_of_work_correct(blockchain.blockchain[0]) and self.verify_transactions(blockchain.blockchain[0])
    def is_proof_of_work_correct(self,block):
        string = generate_hash(block.merkle_tree_root + block.previous_block_hash + str(block.nounce),type=self.hash_type)
        return count_leading_zero_string(string) == self.proof_of_work_zeros
    
    def verify_transaction(self,transaction):
        for row in transaction.tx_in:
            if row.prev_output_tid not in self.blockchain.utxo and transaction.t_type!='COINBASE':
                return False

        signaure_verified = transaction.verify_sign_transaction()
        return signaure_verified
    
    def verify_transactions(self,block):
        for transaction in block.transactions:
            if not self.verify_transaction(transaction):
                return False
        return True
    
#     def add_block(self,block):
#         if proof_of_work_correct(block):
#             if transactions_verified(block):
#                 print("added to block chain")
    


    ### code to add to block chain
